# Instructions pour les agents

- L'application est composée d'un backend FastAPI (dossier `backend/`) et d'un frontend statique (dossier `frontend/`).
- Les notifications sont des Web Push (titre + corps + image + lien optionnels) gérés via service worker (`frontend/sw.js`).
- La base de données cible est MySQL ; utilisez la variable d'environnement `DATABASE_URL` (format `mysql+mysqlconnector://user:pass@host:port/db`).
- Renseignez les clés VAPID (`VAPID_PUBLIC_KEY`, `VAPID_PRIVATE_KEY`, `VAPID_CLAIM_EMAIL`) avant d'appeler `/api/config` ou d'envoyer des notifications.
- Si le schéma SQL change, déplacez l'ancien contenu de `last_update.sql` dans `last_update_old.sql` et écrivez le nouveau SQL dans `last_update.sql`.
- Ne générez pas de fichiers binaires ; privilégiez les assets statiques (HTML/CSS/JS).
- Pour vérifier rapidement le code sans MySQL local, le backend accepte aussi SQLite si `DATABASE_URL` pointe vers `sqlite:///...`.
- Le frontend est servi par FastAPI via `StaticFiles`. Les pages principales : `index.html` (inscription) et `admin.html` (envoi des notifications).
- Commande de démarrage locale : `uvicorn backend.main:app --host 0.0.0.0 --port 8000` après avoir installé les dépendances (`pip install -r requirements.txt`).
- La pile Docker est définie par `docker-compose.yml` (services `db` et `app`).
- Si l'API retourne `Unknown column 'click_url' in 'field list'`, exécuter le script `last_update.sql` (nouvelle colonne `click_url` dans `notifications`) après avoir archivé l'ancien fichier dans `last_update_old.sql`.
- Si l'API retourne `Unknown column 'subscribers.label' in 'field list'`, exécuter le script `last_update.sql` pour aligner la table `subscribers` (colonne `label` + champs Web Push) après avoir archivé la version précédente dans `last_update_old.sql`.
- Les commerces sont gérés via `/api/businesses` (nom, gérant, contact, adresse, abonné optionnel). Utiliser le champ `subscriber_id` pour lier un commerce à un abonné et permettre les envois ciblés (`business_id` dans `/api/notifications`).
- Mise à jour schéma 2025-11-25 : table `businesses` + colonne `business_id` sur `notifications`. Exécuter `last_update.sql` sur les bases existantes après avoir archivé l'ancienne version dans `last_update_old.sql`.
- Mise à jour schéma 2025-11-27 : les instructions d'alignement MySQL sont désormais séparées (une colonne/contrainte/index par `ALTER TABLE` ou `DROP/ADD`) pour éviter l'erreur de syntaxe `ADD COLUMN IF NOT EXISTS` observée au démarrage. Si vous voyez cette erreur, déplacez l'ancien `last_update.sql` vers `last_update_old.sql` puis rejouez le nouveau script.
- Mise à jour schéma 2025-11-27 (correctif) : `last_update.sql` utilise maintenant des blocs préparés (`SET @sql := IF(...); PREPARE stmt FROM @sql; EXECUTE stmt;`) pour vérifier l'existence des colonnes/index/contraintes avant d'exécuter chaque `ALTER TABLE`. Cette version est compatible MySQL 8.0 sans utiliser `ADD COLUMN IF NOT EXISTS` et reste idempotente.
- Le lien d'inscription dédié à un commerce se génère depuis `admin.html` (bouton « Générer un lien d'enrôlement »). Le lien redirige vers `index.html?business_id=...&business_name=...` et `/api/subscribers` associe automatiquement l'abonné au commerce via `business_id`.
- Si aucune clé VAPID n'est fournie via les variables d'environnement, l'API en génère une paire de développement et la stocke dans `backend/.vapid_keys.json` (ignoré par git). Fournir vos propres clés en production pour éviter de régénérer les abonnements.
- Les clés VAPID de développement sont préremplies dans `docker-compose.yml` avec l'email `mailto:moilechevallier@gmail.com`. Mettez-les à jour si vous remplacez la paire ou si vous voulez tester avec d'autres identifiants.
- Depuis py_vapid 1.9, `b64urlencode` renvoie directement une chaîne : ne pas appeler `.decode()` sur le résultat sous peine d'erreur `AttributeError: 'str' object has no attribute 'decode'`. Utiliser un helper qui gère `str` ou `bytes`.
- Au démarrage, l'API applique automatiquement le script `last_update.sql` sur les bases MySQL (idempotent) afin de garantir la présence des colonnes Web Push (`subscribers.label`, `click_url`, etc.). Ne modifiez pas ce comportement : mettez plutôt à jour le contenu du script si le schéma évolue.
- Si l'ajout de l'index `uq_subscriber_endpoint` échoue avec `Duplicate entry '' for key 'subscribers.uq_subscriber_endpoint'`, rejouez la version 2025-11-28 de `last_update.sql` qui supprime les endpoints vides et déduplique les abonnés avant de recréer l'index.
- Si l'erreur `Field 'target_url' doesn't have a default value` apparaît lors de l'envoi d'une notification, appliquez la version 2025-11-29 de `last_update.sql` : elle rend `target_url` facultative, copie ses données vers `click_url` puis supprime la colonne obsolète.
- Sur pywebpush 2.0 et versions ultérieures, l'appel `webpush` n'accepte plus le paramètre `vapid_public_key`. Utilisez uniquement `vapid_private_key` et `vapid_claims` pour éviter l'exception `TypeError: webpush() got an unexpected keyword argument 'vapid_public_key'`.
